ML<-dat@ML[simno,]
mulen<-NA
SRAout<-StochasticSRA_MSC(OM,CAA,Chist,Ind,ML,CAL,mulen,wts=c(1,1,0.5,0.1,1),
Jump_fac=1,nits=200, burnin=100,thin=10,ESS=300,MLsd=0.1,
ploty=F,nplot=6,SRAdir=NA,shiny=F)
framedir<-"C:/GitHub/FRAME/inst/shiny_apps/FRAME"
allfiles<-list.files(framedir)
Rfiles<-allfiles[grepl(".R",allfiles)&!grepl(".Rmd",allfiles)&!allfiles%in%c("server.R","ui.R")]
for(i in 1:length(Rfiles))source(paste0(framedir,"/",Rfiles[i]))
# Test SRA
dat<-XL2Data("Example_data.csv")
OM<-readRDS("YFT.OM")
simno<-1
CAA<-dat@CAA[simno,,]
Chist<-dat@Cat[simno,]
Ind<-dat@Ind[simno,]
CAL=NA
ML<-dat@ML[simno,]
mulen<-NA
SRAout<-StochasticSRA_MSC(OM,CAA,Chist,Ind,ML,CAL,mulen,wts=c(1,1,0.5,0.1,1),
Jump_fac=1,nits=200, burnin=100,thin=10,ESS=300,MLsd=0.1,
ploty=F,nplot=6,SRAdir=NA,shiny=F)
SRAout<-StochasticSRA_MSC(OM,CAA,Chist,Ind,ML,CAL,mulen,wts=c(1,1,0.5,0.1,1),
Jump_fac=1,nits=200, burnin=100,thin=10,ESS=300,MLsd=0.1,
ploty=T,nplot=6,SRAdir=NA,shiny=F)
class(SRAout)
params=list("OM"=SRAout)
myMSE<-runMSE(params$OM,Hist=T)
OM@isRel
names(OM@cpars)
OM@cpars$L5
OM@cpars$LFS
OM@Linf
wts=c(1,1,0.5,0.1,1);Jump_fac=1;nits=200; burnin=100; thin=10; ESS=300; MLsd=0.1; ploty=T; nplot=6; SRAdir=NA; shiny=F
OM <- updateMSE(OM) # Check that all required slots in OM object contain values
nyears<-length(Chist)
if(class(Chist)=="matrix")nyears<-nrow(Chist)
maxage<-OM@maxage
if(length(Ind)==1){
Ind<-rep(NA,nyears)
}else{
if(sum(is.na(Ind))<nyears)Ind<-Ind/mean(Ind,na.rm=T) # normalize Ind to mean 1
}
if(length(ML)==1)ML<-rep(NA,nyears)
Umax<-1-exp(-OM@maxF) # get SRA umax from OM
Imiss<-is.na(Ind)     # which SSB index observations are missing?
proyears<-OM@proyears
nsim<-OM@nsim
Cobs<-runif(nsim,OM@Cobs[1],OM@Cobs[2]) # sample observation error
Iobs=runif(nsim,OM@Iobs[1],OM@Iobs[2])  # use the OM obs error for index
if (OM@nyears != nyears) {
message("OM@nyears being updated to length Chist: ", nyears)
OM@nyears <- nyears
}
if(sum(is.na(Chist))>0){
message("One or more of the historical annual catch observations is missing. Linear interpolation has been used to fill these data")
Chistold<-Chist
Chist<-approx(Chist)$y
cond<-!is.na(Chistold)
Chist[(1:nyears)[cond]]<-Chistold[(1:nyears)[cond]]
print(data.frame("Catches entered" = Chistold, "Catches interpolated"=Chist))
}
if (dim(CAA)[1] != nyears) stop("Number of CAA rows (", dim(CAA)[1], ") does not equal nyears (", nyears, "). NAs are acceptable")
if (dim(CAA)[2] != OM@maxage) {
message("Number of CAA columns (", dim(CAA)[2], ") does not equal OM@maxage (",  OM@maxage, ")")
message("Assuming no CAA for ages greater than ", dim(CAA)[2], ' and filling with 0s')
addages <- OM@maxage-dim(CAA)[2]
CAA2 <- matrix(0, nrow=nrow(CAA), ncol=addages)
CAA <- cbind(CAA, CAA2)
}
if(length(as.vector(CAL))==1){
CALswitch=F # don't do CAL calcs
CALLH<-0 # likelihood contribution is nil
}else{
if (dim(CAL)[1] != nyears) stop("Number of CAL rows (", dim(CAL)[1], ") does not equal nyears (", nyears, "). NAs are acceptable")
if(is.na(mulen[1])) stop("You must specify the argument mulen, which is the mean length of each length bin (columns) of the CAL data")
if (dim(CAL)[2] != length(mulen)) {
stop("The argument mulen (the mean length of each length bin) should be of the same length as the number of columns of the CAL data")
}
CALyrs<-(1:nrow(CAL))[apply(CAL,1,function(x)sum(is.na(x)))<ncol(CAL)]
CALswitch=T
}
nlen<-length(mulen)
if (burnin < 0.05*nits) burnin <- 0.05 * nits
if("nsim"%in%slotNames(OM))nsim<-OM@nsim
if("proyears"%in%slotNames(OM))proyears<-OM@proyears
OM@nsim<-nsim
OM@proyears<-proyears
# Sample custom parameters
SampCpars <- list() # empty list
# custom parameters exist - sample and write to list
if(length(OM@cpars)>0){
# ncparsim<-cparscheck(OM@cpars)   # check each list object has the same length and if not stop and error report
SampCpars <- SampleCpars(OM@cpars, nsim)
}
# Sample Stock Parameters
options(warn=-1)
StockPars <- SampleStockPars(OM, nsim, nyears, proyears, SampCpars, Msg=FALSE)
options(warn=1)
# Assign Stock pars to function environment
for (X in 1:length(StockPars)) assign(names(StockPars)[X], StockPars[[X]])
agearr<-array(rep(1:maxage,each=nsim),c(nsim,maxage))
Wt_age <- Wt_age[,,nyears] # no time-varying growth
Mat_age<- Mat_age[,,nyears]
Len_age<-Len_age[,,nyears]
# iALK script =================================================
if(CALswitch){
lvar<-runif(nsim,OM@LenCV[1],OM@LenCV[2])
iALK<-array(NA,c(nsim,maxage,nlen))
ind<-as.matrix(expand.grid(1:nsim,1:maxage,1:nlen))
Lind<-ind[,c(1,2)]
iALK[ind]<-dnorm(mulen[ind[,3]],Len_age[Lind],lvar[ind[,1]]*Len_age[Lind])
sums<-apply(iALK,1:2,sum)
sind<-ind[,1:2]
iALK<-iALK/sums[sind]
#contour(x=1:maxage,y=1:nlen,iALK[3,,],nlevels=10)
}
# Sample Fleet Parameters
options(warn=-1)
FleetPars <- SampleFleetPars(SubOM(OM, "Fleet"), Stock=StockPars, nsim,
nyears, proyears, cpars=SampCpars)
options(warn=1)
# Assign Fleet pars to function environment
for (X in 1:length(FleetPars)) assign(names(FleetPars)[X], FleetPars[[X]])
# Sampled arrays
Chist_a<-array(trlnorm(nyears*nsim,1,Cobs)*rep(Chist,each=nsim),c(nsim,nyears)) # Historical catch
# set up mcmc
lnR0<-lninfl<-lnslp<-array(NA,c(nsim,nits))
lnRD<-array(0,c(nsim,nyears+maxage,nits))
LHD<-array(NA,c(nsim,nits))
# if(sfIsRunning())sfExport(list=c("Chist_a"))
if(sfIsRunning()){
R0LB<-sfSapply(1:nsim,LSRA,FF=M*4,Chist_arr=Chist_a,M=M,Mat_age=Mat_age,Wt_age=Wt_age,
sel=Mat_age,Recdevs=array(1,c(nsim,nyears+maxage)),h=hs)
R0UB<-sfSapply(1:nsim,LSRA,FF=M/10,Chist_arr=Chist_a,M=M,Mat_age=Mat_age,Wt_age=Wt_age,
sel=Mat_age,Recdevs=array(1,c(nsim,nyears+maxage)),h=hs)
}else{
R0LB<-sapply(1:nsim,LSRA,FF=M*4,Chist_arr=Chist_a,M=M,Mat_age=Mat_age,Wt_age=Wt_age,
sel=Mat_age,Recdevs=array(1,c(nsim,nyears+maxage)),h=hs)
R0UB<-sapply(1:nsim,LSRA,FF=M/10,Chist_arr=Chist_a,M=M,Mat_age=Mat_age,Wt_age=Wt_age,
sel=Mat_age,Recdevs=array(1,c(nsim,nyears+maxage)),h=hs)
}
R0b=cbind(R0LB-1,R0UB+1)
inflb<-log(c(0.5,maxage*0.5))
slpb<-log(exp(inflb)*c(0.1,2))#c(-3,3)
RDb<-c(-2,2)
# initial guesses
lnR0[,1]<-R0UB#log(apply(Chist_a,1,mean))
lninfl[,1]<-log(maxage/4)
lnslp[,1]<-log(exp(lninfl[,1])*0.2)
lnRD[,,1]<-0
# parameter vector
pars<-c(lnR0[,1],lninfl[,1],lnslp[,1],lnRD[,,1])
npars<-length(pars)
# parameter store
LHstr<-array(NA,c(nsim,nits))
parstr<-array(NA,c(npars,nits))
# parameter indexes
R0ind<-1:nsim
inflind<-(1*nsim)+(1:nsim)
slpind<-(2*nsim)+(1:nsim)
RDind<-(3*nsim+1):length(pars)
# Parameter jumping
JumpCV<-rep(0.05,npars) # R0
JumpCV[inflind]<-0.05
JumpCV[slpind]<-0.05
JumpCV[RDind]<-0.1*mean(procsd) # a function of sigmaR to provide reasonable acceptance rate
JumpCV<-JumpCV*Jump_fac
# parameter censorship
parLB<-parUB<-rep(NA,length(pars))
parLB[R0ind]<-R0b[,1]
parLB[inflind]<-inflb[1]
parLB[slpind]<-slpb[1]
parLB[RDind]<-RDb[1]
parUB[R0ind]<-R0b[,2]
parUB[inflind]<-inflb[2]
parUB[slpind]<-slpb[2]
parUB[RDind]<-RDb[2]
CAAadj=sum(CAA,na.rm=T)/ESS # ESS adjustment to low sample sizes
CALadj=sum(CAL,na.rm=T)/ESS # ESS adjustment to low sample sizes
update<-(1:50)*(nits/50)
adapt<-c(rep(5,100),rep(2.5,100),rep(1,nits-200))
CAA_pred<-array(NA,c(nsim,nyears,maxage))
if(CALswitch){
CAL_pred<-array(NA,c(nsim,nyears,nlen))
CALtemp<-array(NA,c(nsim,maxage,nlen))
CAAind<-cbind(ind[,1],rep(1,nsim*maxage),ind[,2]) # sim, year, age
}
PredF<-MLpred<-SSB<-array(NA,c(nsim,nyears))
upprog<-floor((1:20)*(nits/20))
for(i in 1:nits){
if(i %in% update){
cat(".")
flush.console()
}
#i<-i+1# debugging
Reject<-rep(FALSE,nsim)
nupars<-rnorm(npars,pars,JumpCV*adapt[i])
nupars[nupars<parLB]<-parLB[nupars<parLB]
nupars[nupars>parUB]<-parUB[nupars>parUB]
if(i==1)nupars=pars
R0<-exp(nupars[R0ind])
infl<-exp(nupars[inflind])
#infl<-(0.05+(infl/(1+infl))*0.45)*maxage
slp<-exp(nupars[slpind])
#slp<-(0.02+(slp/(1+slp))*0.98)*infl
RD<-exp(array(nupars[RDind],c(nsim,nyears+maxage)))
RD<-RD/apply(RD,1,mean)
sel<-1/(1+exp((infl-(agearr))/slp))
# calcs (getting pen as a zero or a 1)
N<-R0*exp(-M*(agearr-1))
SSB0<-apply(N*Mat_age*Wt_age,1,sum)
SSBpR<-SSB0/R0
CAA_pred[]<-NA
if(CALswitch)CAL_pred[]<-0
PredF[]<-NA
MLpred[]<-NA
SSB[]<-NA
for(y in 1:nyears){  # M - F - aging / recruitment
if(y==1)N<-N*RD[,maxage:1]
SSB[,y]<-apply(N*Mat_age*Wt_age,1,sum)
PredN<-N*exp(-M/2)
PredVN<-PredN*sel
CAA_pred[,y,]<-PredVN/apply(PredVN,1,sum)
if(CALswitch){
if(y%in%CALyrs){
CAAind[,2]<-y
CALtemp[ind]<-iALK[ind]*CAA_pred[CAAind]
CAL_pred[,y,]<-CAL_pred[,y,]+apply(CALtemp,c(1,3),sum)
}
}
MLpred[,y]<-apply(CAA_pred[,y,]*Len_age,1,sum)/apply(CAA_pred[,y,],1,sum)
PredVW<-PredVN*Wt_age                   # Predicted vulnerable weight
Predfrac<-PredVW/apply(PredVW,1,sum)    # Catch weight distribution over ages
Cat<-(Chist_a[,y]*Predfrac)/Wt_age      # Guess at catch numbers by age
predU<-Cat/PredN                        # Which means this harvest rate
predU[!is.finite(predU)] <- Inf
cond<-predU>Umax                        # Check max U
Reject[apply(cond,1,sum)>0]<-TRUE       # Reject sims where U > Umax for any age class
Cat[cond]<-Cat[cond]/(predU[cond]/Umax) # Set catch to Umax
PredF[,y]<--log(1-apply(Cat/PredN,1,max)) # apical F
N<-N*exp(-M)-Cat #PredF[,y]*sel)
N[,2:maxage]<-N[,1:(maxage-1)] # aging
N[,1]<-RD[,maxage+y]*(0.8*R0*hs*SSB[,y])/(0.2*SSBpR*R0*(1-hs)+(hs-0.2)*SSB[,y])
N[N<0] <- tiny
}
Ipred<-SSB
Ipred[matrix(rep(Imiss,each=nsim),nrow=nsim)]<-NA
Ipred<-Ipred/apply(Ipred,1,mean,na.rm=T)
Ires<-Ipred/matrix(rep(Ind,each=nsim),nrow=nsim)
MLres<-MLpred/matrix(rep(ML,each=nsim),nrow=nsim)
Ires[Ires<(1E-10)]<-(1E-10)
Ires[Ires>1E10]<-1E10
MLres[MLres<(1E-10)]<-(1E-10)
MLres[MLres>1E10]<-1E10
CAA_pred[CAA_pred<1E-15]<-1E-15
if(CALswitch){
CAL_pred<-CAL_pred/array(apply(CAL_pred,1:2,sum),dim(CAL_pred))
CAL_pred[CAL_pred<1E-15]<-1E-15
}
CAALH<-apply(log(CAA_pred)*
array(rep(CAA,each=nsim)/CAAadj,c(nsim,nyears,maxage)),
1,sum,na.rm=T)
if(CALswitch){
CALLH<-apply(log(CAL_pred[,CALyrs,])*
array(rep(CAL[CALyrs,],each=nsim)/CALadj,c(nsim,length(CALyrs),nlen)),
1,sum,na.rm=T)
}
RDLH<-apply(matrix(dnorm(nupars[RDind],-(procsd^2)/2,procsd,log=T),nrow=nsim),1,sum)
ILH<-apply(dnorm(log(Ires),-(Iobs^2)/2,Iobs,log=T),1,sum,na.rm=T)
MLLH<-apply(dnorm(log(MLres),-(MLsd^2)/2,MLsd,log=T),1,sum,na.rm=T)
LH<-wts[1]*CAALH+wts[2]*RDLH+wts[3]*ILH+wts[4]*MLLH+wts[5]*CALLH
# Reject / accept (cond)
if(i > 1){
Accept<-runif(nsim)<exp(LH-LHstr[,i-1])
Accept[Reject]<-FALSE
LHstr[,i]<-LHstr[,i-1]
LHstr[Accept,i]<-LH[Accept]
Aind<-rep(Accept,npars/nsim) # The correct index in the pars vector for the accepted simulations
parstr[,i]<-parstr[,i-1]
parstr[Aind,i]<-nupars[Aind]
pars<-parstr[,i]
# print(rbind(Reject,Accept))
}else{
parstr[,i]<-pars
LHstr[,i]<-LH
}
if(shiny)if(i %in% upprog)incProgress(1/20, detail = round(i*100/nits))
} # End of MCMC
col<-rep(c("blue","red","green","orange","grey","brown","pink","yellow","dark red","dark blue","dark green"),100)
par(mfcol=c(5,2),mai=c(0.7,0.6,0.05,0.1))
pind<-(1:(nits/thin))*thin
matplot(pind,t(parstr[1:nplot,pind]),type='l',ylab="log R0",xlab="Iteration")
abline(v=burnin,lty=2)
matplot(pind,t(parstr[nsim+(1:nplot),pind]),type='l',ylab="log infl (sel)",xlab="Iteration")
abline(v=burnin,lty=2)
matplot(pind,t(parstr[(nsim*2)+(1:nplot),pind]),type='l',ylab="log slp (sel)",xlab="Iteration")
abline(v=burnin,lty=2)
matplot(pind,t(parstr[(nsim*30)+(1:nplot),pind]),type='l',ylab="recdev1",xlab="Iteration")
abline(v=burnin,lty=2)
matplot(pind,t(parstr[(nsim*40)+(1:nplot),pind]),type='l',ylab="recdev2",xlab="Iteration")
abline(v=burnin,lty=2)
burn<-burnin:nits
plot(density(parstr[1:nsim,burn],adj=0.7),xlab="log(R0)",main="")
plot(density(parstr[nsim+(1:nsim),burn],adj=0.7),xlab="inflection selectivity",main="")
plot(density(parstr[(nsim*2)+(1:nsim),burn],adj=0.7),xlab="slope selectivity",main="")
plot(density(parstr[(nsim*30)+(1:nsim),burn],adj=0.7),xlab="recdev1",main="")
plot(density(parstr[(nsim*40)+(1:nsim),burn],adj=0.7),xlab="recdev2",main="")
par(mfrow=c(6,2),mai=c(0.65,0.6,0.02,0.1))
qq<-apply(SSB,2,quantile,p=c(0.05,0.25,0.5,0.75,0.95))
ylim<-c(0,max(qq))
matplot(t(SSB[1:nplot,]),ylim=ylim,type="l",xlab="Year",ylab="SSB")
xs<-dim(SSB)[2]
plot(qq[3,],ylim=ylim,type='l',xlab="Year",ylab="SSB")
polygon(c(1:xs,xs:1),c(qq[1,],qq[5,xs:1]),border=NA,col='light grey')
polygon(c(1:xs,xs:1),c(qq[2,],qq[4,xs:1]),border=NA,col='dark grey')
lines(qq[3,],lwd=1,col="white")
D<-SSB/SSB0
qq<-apply(D,2,quantile,p=c(0.05,0.25,0.5,0.75,0.95))
ylim<-c(0,max(qq))
matplot(t(D[1:nplot,]),ylim=ylim,type="l",xlab="Year",ylab="Depletion")
plot(qq[3,],ylim=ylim,type='l',xlab="Year",ylab="Depletion")
polygon(c(1:xs,xs:1),c(qq[1,],qq[5,xs:1]),border=NA,col='light grey')
polygon(c(1:xs,xs:1),c(qq[2,],qq[4,xs:1]),border=NA,col='dark grey')
lines(qq[3,],lwd=1,col="white")
qq<-apply(PredF,2,quantile,p=c(0.05,0.25,0.5,0.75,0.95))
ylim<-c(0,max(qq))
matplot(t(PredF[1:nplot,]),ylim=ylim,type="l",xlab="Year",ylab="Fish. Mort.")
plot(qq[3,],ylim=ylim,type='l',xlab="Year",ylab="Fish. Mort.")
polygon(c(1:xs,xs:1),c(qq[1,],qq[5,xs:1]),border=NA,col='light grey')
polygon(c(1:xs,xs:1),c(qq[2,],qq[4,xs:1]),border=NA,col='dark grey')
lines(qq[3,],lwd=1,col="white")
nyears<-dim(CAA)[1]
nages<-dim(CAA)[2]
qq<-apply(sel,2,quantile,p=c(0.05,0.25,0.5,0.75,0.95))
ylim<-c(0,max(qq))
xs<-maxage
matplot(t(sel[1:nplot,]),ylim=ylim,type="l",xlab="Age",ylab="Selectivity")
plot(qq[3,],ylim=ylim,type='l',xlab="Age",ylab="Selectivity")
polygon(c(1:xs,xs:1),c(qq[1,],qq[5,xs:1]),border=NA,col='light grey')
polygon(c(1:xs,xs:1),c(qq[2,],qq[4,xs:1]),border=NA,col='dark grey')
lines(qq[3,],lwd=1,col="white")
sel[1:nplot,]
infl
slp
A5<--(slp*log(1/0.05-1)-infl)
A5
A95<--(slp*log(1/0.95-1)-infl)
(1-exp(-K*(A5-t0)))
Linf
L5<-Linf*(1-exp(-K*(A5-t0)))
L95<-Linf*(1-exp(-K*(A95-t0)))
L5
L95
A5<--(slp*log(1/0.05-1)-infl)
A5
A5<--(slp*log(1/0.05-1)-infl)
A5[A5<0]A5<-0.01
A95<--(slp*log(1/0.95-1)-infl)
L5<-Linf*(1-exp(-K*(A5-t0)))
L95<-Linf*(1-exp(-K*(A95-t0)))
A5<--(slp*log(1/0.05-1)-infl)
A5[A5<0]<-0.01
A95<--(slp*log(1/0.95-1)-infl)
L5<-Linf*(1-exp(-K*(A5-t0)))
L95<-Linf*(1-exp(-K*(A95-t0)))
OM@L5<-quantile(L5,c(0.05,0.95))
OM@LFS<-quantile(L95,c(0.05,0.95))
OM@nyears<-nyears
OM@EffYears<-1:OM@nyears
OM@EffLower<-apply(PredF,2,quantile,p=0.05)
OM@EffUpper<-apply(PredF,2,quantile,p=0.95)
OM@nyears<-nyears
Perr<-array(NA,c(nsim,maxage+nyears+proyears-1))
Perr[,1:(nyears+maxage-1)]<-log(RD[,2:(maxage+nyears)])
Perr[,(nyears+maxage):(nyears+maxage+proyears-1)]<-matrix(rnorm(nsim*(proyears),rep(procmu,proyears),rep(procsd,proyears)),nrow=nsim)
for (y in (maxage+nyears):(nyears + proyears+maxage-1)) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
Perr<-exp(Perr)
PredF<-PredF/apply(PredF,1,mean) # Find should be mean 1 so qs optimizers are standardized
Wt_age <- array(Wt_age, dim=c(dim=c(nsim, maxage, nyears+proyears)))
Len_age <- array(Len_age, dim=c(nsim, maxage, nyears+proyears))
Marray <- matrix(M, nrow=nsim, ncol=proyears+nyears)
OM@cpars<-list(D=dep,M=M,procsd=procsd,AC=AC,hs=hs,Linf=Linf,
Wt_age=Wt_age, Len_age=Len_age, Marray=Marray,
K=K,t0=t0,L50=L50,
L5=L5,LFS=L95,Find=PredF,
V=array(sel,c(nsim,maxage,nyears)),Perr=Perr,R0=R0,
Iobs=apply(Ires,1,sd,na.rm=T),
SSB=SSB,SSB0=SSB0,RD=RD) # not valid for runMSE code but required
dep<-SSB[,nyears]/SSB0
procsd<-apply(RD,1,sd,na.rm=T)
procmu <- -0.5 * (procsd)^2  # adjusted log normal mean
OM@D<-quantile(dep,c(0.05,0.95))
OM@Perr<-quantile(procsd,c(0.025,0.975))
dep
getAC<-function(recdev)acf(recdev,plot=F)$acf[2,1,1]
AC<-apply(RD,1,getAC)
OM@AC<-quantile(AC,c(0.05,0.95))
A5<--(slp*log(1/0.05-1)-infl)
A5[A5<0]<-0.01
A95<--(slp*log(1/0.95-1)-infl)
L5<-Linf*(1-exp(-K*(A5-t0)))
L95<-Linf*(1-exp(-K*(A95-t0)))
OM@L5<-quantile(L5,c(0.05,0.95))
OM@LFS<-quantile(L95,c(0.05,0.95))
OM@nyears<-nyears
OM@EffYears<-1:OM@nyears
OM@EffLower<-apply(PredF,2,quantile,p=0.05)
OM@EffUpper<-apply(PredF,2,quantile,p=0.95)
OM@nyears<-nyears
Perr<-array(NA,c(nsim,maxage+nyears+proyears-1))
Perr[,1:(nyears+maxage-1)]<-log(RD[,2:(maxage+nyears)])
Perr[,(nyears+maxage):(nyears+maxage+proyears-1)]<-matrix(rnorm(nsim*(proyears),rep(procmu,proyears),rep(procsd,proyears)),nrow=nsim)
for (y in (maxage+nyears):(nyears + proyears+maxage-1)) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
Perr<-exp(Perr)
PredF<-PredF/apply(PredF,1,mean) # Find should be mean 1 so qs optimizers are standardized
Wt_age <- array(Wt_age, dim=c(dim=c(nsim, maxage, nyears+proyears)))
Len_age <- array(Len_age, dim=c(nsim, maxage, nyears+proyears))
Marray <- matrix(M, nrow=nsim, ncol=proyears+nyears)
OM@cpars<-list(D=dep,M=M,procsd=procsd,AC=AC,hs=hs,Linf=Linf,
Wt_age=Wt_age, Len_age=Len_age, Marray=Marray,
K=K,t0=t0,L50=L50,
L5=L5,LFS=L95,Find=PredF,
V=array(sel,c(nsim,maxage,nyears)),Perr=Perr,R0=R0,
Iobs=apply(Ires,1,sd,na.rm=T),
SSB=SSB,SSB0=SSB0,RD=RD) # not valid for runMSE code but required
plot(OM)
params=list("OM"=SRAout)
myMSE<-runMSE(params$OM,Hist=T)
sel<-myMSE$AtAge$Sl_age[,,1]
matplot(t(sel),type='l',xlab="Age",ylab="Selectivity")
runApp('C:/GitHub/FRAME/inst/shiny_apps/FRAME')
setwd("C:/App")
# Frame source code
framedir<-"C:/GitHub/FRAME/inst/shiny_apps/FRAME"
allfiles<-list.files(framedir)
Rfiles<-allfiles[grepl(".R",allfiles)&!grepl(".Rmd",allfiles)&!allfiles%in%c("server.R","ui.R")]
for(i in 1:length(Rfiles))source(paste0(framedir,"/",Rfiles[i]))
dat<-XL2Data("Example_indicator_data.csv")
OM<-readRDS("YFT.OM")
simno<-1
CAA<-dat@CAA[simno,,]
Chist<-dat@Cat[simno,]
Ind<-dat@Ind[simno,]
CAL=NA
ML<-dat@ML[simno,]
mulen<-NA
wts=c(1,1,0.5,0.1,1);Jump_fac=1;nits=200; burnin=100; thin=10; ESS=300; MLsd=0.1; ploty=T; nplot=6; SRAdir=NA; shiny=F
OM <- updateMSE(OM) # Check that all required slots in OM object contain values
nyears<-length(Chist)
if(class(Chist)=="matrix")nyears<-nrow(Chist)
maxage<-OM@maxage
if(length(Ind)==1){
Ind<-rep(NA,nyears)
}else{
if(sum(is.na(Ind))<nyears)Ind<-Ind/mean(Ind,na.rm=T) # normalize Ind to mean 1
}
if(length(ML)==1)ML<-rep(NA,nyears)
Umax<-1-exp(-OM@maxF) # get SRA umax from OM
Imiss<-is.na(Ind)     # which SSB index observations are missing?
proyears<-OM@proyears
nsim<-OM@nsim
Cobs<-runif(nsim,OM@Cobs[1],OM@Cobs[2]) # sample observation error
Iobs=runif(nsim,OM@Iobs[1],OM@Iobs[2])  # use the OM obs error for index
if (OM@nyears != nyears) {
message("OM@nyears being updated to length Chist: ", nyears)
OM@nyears <- nyears
}
if(sum(is.na(Chist))>0){
message("One or more of the historical annual catch observations is missing. Linear interpolation has been used to fill these data")
Chistold<-Chist
Chist<-approx(Chist)$y
cond<-!is.na(Chistold)
Chist[(1:nyears)[cond]]<-Chistold[(1:nyears)[cond]]
print(data.frame("Catches entered" = Chistold, "Catches interpolated"=Chist))
}
if (dim(CAA)[1] != nyears) stop("Number of CAA rows (", dim(CAA)[1], ") does not equal nyears (", nyears, "). NAs are acceptable")
if (dim(CAA)[2] != OM@maxage) {
message("Number of CAA columns (", dim(CAA)[2], ") does not equal OM@maxage (",  OM@maxage, ")")
message("Assuming no CAA for ages greater than ", dim(CAA)[2], ' and filling with 0s')
addages <- OM@maxage-dim(CAA)[2]
CAA2 <- matrix(0, nrow=nrow(CAA), ncol=addages)
CAA <- cbind(CAA, CAA2)
}
if(length(as.vector(CAL))==1){
CALswitch=F # don't do CAL calcs
CALLH<-0 # likelihood contribution is nil
}else{
if (dim(CAL)[1] != nyears) stop("Number of CAL rows (", dim(CAL)[1], ") does not equal nyears (", nyears, "). NAs are acceptable")
if(is.na(mulen[1])) stop("You must specify the argument mulen, which is the mean length of each length bin (columns) of the CAL data")
if (dim(CAL)[2] != length(mulen)) {
stop("The argument mulen (the mean length of each length bin) should be of the same length as the number of columns of the CAL data")
}
CALyrs<-(1:nrow(CAL))[apply(CAL,1,function(x)sum(is.na(x)))<ncol(CAL)]
CALswitch=T
}
nlen<-length(mulen)
dat<-XL2Data("Example_indicator_data.csv")
OM<-readRDS("YFT.OM")
simno<-1
CAA<-dat@CAA[simno,,]
Chist<-dat@Cat[simno,]
Ind<-dat@Ind[simno,]
CAL=NA
ML<-dat@ML[simno,]
mulen<-NA
SRAout<-StochasticSRA_MSC(OM,CAA,Chist,Ind,ML,CAL,mulen,wts=c(1,1,0.5,0.1,1),
Jump_fac=1,nits=200, burnin=100,thin=10,ESS=300,MLsd=0.1,
ploty=T,nplot=6,SRAdir=NA,shiny=F)
runApp('C:/GitHub/FRAME/inst/shiny_apps/FRAME')
library(FRAME)
library(FRAME)
