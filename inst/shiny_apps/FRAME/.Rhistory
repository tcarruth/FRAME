Base@RDno=RDno
Base@RDts=RDts
Base@spawns<-c(2,2)
Base@canspawn<-matrix(c(0,0,0,0,0,0,1,  1,1,0,0,0,0,0),ncol=Base@np) # matrix of spawning areas 1=can spawn
#   Age             1      2     3     4    5      6    7     8     9     10    11    12    13    14   15   16   17  18+
Base@Ma<-t(array(c(0.38, 0.30, 0.24, 0.20, 0.18, 0.16, 0.14, 0.13, 0.12, 0.12, 0.11, 0.11, 0.11, 0.1, 0.1, 0.1, 0.1, 0.1,rep(0.1,Base@na-18)),c(Base@na,Base@np)))
surv<-exp(-t(apply(cbind(c(0,0),Base@Ma[,1:(Base@na-1)]),1,cumsum)))
Base@SSBpR<-apply(surv*Base@Fec,1,sum)+surv[,Base@na]*exp(-Base@Ma[,Base@na])/(1-exp(-Base@Ma[,Base@na]))*Base@Fec[,Base@na]
# --- (d) Process CATDIS data ------
source("RScripts/Data processing/CATDIS.r") # returns Cobs in the right format
Base@Cobs<-as.matrix(Cobs)
Base@nCobs<-nrow(Cobs)
# --- (e) Calculate master indices ------
source("Rscripts/Data processing/Master index.r") # returns list MI: MI[[1]] 0% efficiency increase MI[[2]] 2% efficiency increase MI[[3]] minus MA TP plus CAN LL 0% efficiency increase MI[[4]] minus MA TP plus CAN LL 2% efficiency increase
Base@RAI=MI[[1]]
source("Rscripts/Data processing/Partial Fs.r") # returns CPUEobs
Base@nE<-Base@nf # same number of cpue indices (if not using master index) as fleets
Base@nEobs<-nrow(Eobs)
Base@Eobs<-Eobs
# --- (g) Process assessment indices ----
source("Rscripts/Data processing/Fishery indices.r") # returns CPUEqvec and CPUEobs in the right format
Base@nCPUEq<-max(CPUEobs$qNo)
Base@nCPUEobs<-nrow(CPUEobs)
Base@CPUEobs<-as.matrix(CPUEobs)
Base@CPUEnames<-CPUEnames
CPUEup<-10
#              "SPN_BB" "SPN_FR_BB" "MOR_SPN_TRAP" "MOR_POR_TRAP" "JPN_LL_Eatl_Med" "JPN_LL_NEAtl1" "JPN_LL_NEAtl2" "US_RR_66_114" "US_RR_115_144" "US_RR_177" "US_RR_145" "US_RR_195" "US_GOM_PLL1" "US_GOM_PLL2" "JPLL_GOM" "JPN_LL_West1" "JPN_LL_West2" "CAN GSL" "CAN SWNS"
Base@CPUEwt <-c(1,       1,          1,             1,             CPUEup,           1,              1,              1,             1,              1,          CPUEup*2,          1,          1,       CPUEup,            1,   CPUEup*2,             1,         1/CPUEup,  1/CPUEup)
# --- (h) Calculate length sample data ------
source("Rscripts/Data processing/Length observations.r") # returns CLobs
Base@nCLobs<-nrow(CLobs)
Base@CLobs<-as.matrix(CLobs)
# --- (i) Calculate historical catches ------
source("Rscripts/Data processing/Historical catches old.r") # returns HCobs
Base@HCobs<-HCobs # a 4D array y x s x a x  r
# --- (j) Fishery independent indices ------
source("Rscripts/Data processing/FI indices.r") # returns Iobs and Inames
Base@nI<-as.integer(max(Iobs[,5])) # number of series
Base@nIobs<-nrow(Iobs) # number of data
Base@Iobs<-Iobs   # y s r i type(biomass/ssb) index
Base@Inames<-Inames
Iup<-6
#          "FR_AER_SUV1" "FR_AER_SUV2" "MED_LAR_SUV" "CAN_ACO_SUV" "GOM_LAR_SUV" "GBYP_AER_SUV"
Base@Iwt<-c(1,            1,            Iup,            Iup,            Iup,            1)
# --- (k) PSAT tags ------
Base@nma<-as.integer(3)
Base@ma<-c(rep(1,4),rep(2,4),rep(3,Base@na-8))
Impute=TRUE # Do you want to use movement fingerprinting to identify more PSATs?
source("Rscripts/Data processing/PSAT.r") # returns a table of electronic tag tracks of known (PSAT) and unknown (PSAT2) stock of origin
Base@nPSAT<-nrow(PSAT)
Base@PSAT<-PSAT
Base@nPSAT2<-nrow(PSAT2)
Base@PSAT2<-PSAT2
# --- Conventional tags ------
Base@nTag<-as.integer(1) # currently this is placeholder for conventional tags that are ignored by M3
Base@Tag<-array(c(2,1,7,1,2,2,7,1,2,1),c(1,10))
# --- (l) Stock of origin observations ------
ma<-array(rep(c(rep(1,3),rep(2,5),rep(3,Base@na-8)),each=Base@np),c(Base@np,Base@na))
nma<-max(ma)
add_Genetics=F
summary=F
testSOO=F
source("Rscripts/Data processing/SOO.r")
Base@nSOOobs<-nrow(SOOobs)
Base@SOOobs<-SOOobs
# --- Selectivities ------
Base@nsel<-Base@nf
Base@seltype<-rep(3,Base@nf) # all fleets have thompson (potentially) dome-shaped selectivity except the combined other fleet
Base@seltype[(1:length(Fleets$name))[Fleets$name%in%c("LLOTH","RRCan")]]<-2 # set longline to asymptotic
Base@seltype[length(Base@seltype)]<-2
Base@selind<-1:Base@nf # No selectivity mirroring - selectivities correspond to fleets
Base@ratiolim<-c(0.1,0.4) # limits on the logistic slope paramter relative to position of inflection point
Base@infleclim<-c(4,15) # limits on the location of the inflection point (age)
# --- (m) Movement estimation and definition ------
Base@movtype<-as.integer(1)
source("Rscripts/Data processing/Movement definitions.r") # returns movind and mov1
Base@nMP<-nrow(movind)+Base@ns*Base@np*Base@nma
Base@nmovind<-nrow(movind)
Base@movind<-movind
Base@nmov1<-nrow(mov1)
Base@mov1<-mov1
# --- Relating to likelihood functions ------
Base@CobsCV<-rep(0.025,Base@nf)        # CV on seasonal catch observations by area
#                "SPN_BB" "SPN_FR_BB" "MOR_SPN_TRAP" "MOR_POR_TRAP" "JPN_LL_Eatl_Med" "JPN_LL_NEAtl1" "JPN_LL_NEAtl2" "US_RR_66_114" "US_RR_115_144" "US_RR_177" "US_RR_145" "US_RR_195" "US_GOM_PLL1" "US_GOM_PLL2" "JPLL_GOM" "JPN_LL_West1" "JPN_LL_West2" "CAN GSL" "CAN SWNS"
Base@CPUEobsCV<-c(0.2,     0.2,        0.2,           0.2,           0.15,             0.125,          0.15,           0.2,           0.2,            0.15,       0.1,       0.15,       0.15,         0.15,         0.15,      0.1,           0.2,           0.5,      0.5) # CV on seasonal CPUE observations by area
#              "FR_AER_SUV1" "FR_AER_SUV2" "MED_LAR_SUV" "CAN_ACO_SUV" "GOM_LAR_SUV" "GBYP_AER_SUV"
Base@IobsCV<- c(0.1,          0.15,         0.1,          0.1,          0.1,          0.125)         # CV on fishery independent indices
Base@RDCV<-0.5/(Base@ny/(Base@ny/yblock))^0.5 # CV for penalty on recruitment deviations (if blocked this is Std. Err.)
Base@nSSBprior=1
Base@SSBprior = matrix(c(1,1,20000),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@SSBCV=10                       # default is a very tight prior on SSB
Base@nDepprior=1
Base@Depprior = matrix(c(1,1,0.5),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@DepCV=10                       # default is a very tight prior on SSB
Base@FCV=0.3                          # Prior precision of season-area deviations around mean F
Base@movCV=1                          # Prior precision of deviations from homogeneous movement
Base@selCV=0.8                        # Prior precision of selectivity parameters
Base@SSBincCV=0.01                    # Prior precision of SSB increase ratio
Base@nLHw<-as.integer(15)             # number of likelihood components that may be weighted
#            (1 catch, 2 cpue, 3 FIindex, 4 Lcomp, 5 SOO, 6 PSAT, 7 PSAT2, 8 RecDev, 9 mov,  10 sel,  11 SRA, 12 SSB, 13 SSBinc, 14 Fmod, 15 BSfrac)",datfile,1,append=T)
Base@LHw<-   c(1/5,     0.8 ,   0.1,       1/50,   10,    1,      0,       30,      1,      4,       100,    0,      0,         10,      0 ) # SSB index for each population
#Base@LHw<-  c(1/20,    4 ,     1,         1/20,    10,    1,      0,       10,      1,      10,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       10,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/5,     2 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/2,     4 ,     4,         20,      10,    2,      1,       100,     2,      3,       10,     0,       0,       2000,      0 ) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
save(OMI,file=paste(getwd(),"/Objects/OMs/Base_OM",sep=""))
save(OMI,file=paste(getwd(),"/M3/OMI",sep=""))
input_dir="C:/Users/tcarruth/Dropbox/abft-mse/M3"
out<-M3read(input_dir)
load(paste(input_dir,"/OMI",sep=""))
load(system.file("ts2017.Rdata", package="ABTMSE"))
dat<-ts2017
render(input="C:/Users/tcarruth/Dropbox/abft-mse/R_package/ABTMSE/inst/OMreport.Rmd", output_file=paste("C:/temp/OMreport.html",sep=""))
Base@LHw<-                 c(1/5,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     4,       100,    0,      0,         50,      0 ) # SSB index for each population
# Circulated: Base@LHw<-   c(1/5,     0.8 ,   0.1,       1/50,   10,    1,       0,       30,      1,      4,       100,    0,      0,         10,      0 ) # SSB index for each population
#Base@LHw<-  c(1/20,    4 ,     1,         1/20,    10,    1,      0,       10,      1,      10,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       10,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/5,     2 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/2,     4 ,     4,         20,      10,    2,      1,       100,     2,      3,       10,     0,       0,       2000,      0 ) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
save(OMI,file=paste(getwd(),"/Objects/OMs/Base_OM",sep=""))
save(OMI,file=paste(getwd(),"/M3/OMI",sep=""))
input_dir="C:/Users/tcarruth/Dropbox/abft-mse/M3"
out<-M3read(input_dir)
load(paste(input_dir,"/OMI",sep=""))
load(system.file("ts2017.Rdata", package="ABTMSE"))
dat<-ts2017
render(input="C:/Users/tcarruth/Dropbox/abft-mse/R_package/ABTMSE/inst/OMreport.Rmd", output_file=paste("C:/temp/OMreport2.html",sep=""))
Base@LHw<-                 c(1/3,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     10,       100,    0,      0,        50,      0 ) # SSB index for each population
# revised 2 Base@LHw<-     c(1/5,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     4,       100,    0,      0,         50,      0 ) # SSB index for each population
# Circulated: Base@LHw<-   c(1/5,     0.8 ,   0.1,       1/50,   10,    1,       0,       30,      1,      4,       100,    0,      0,         10,      0 ) # SSB index for each population
#Base@LHw<-  c(1/20,    4 ,     1,         1/20,    10,    1,      0,       10,      1,      10,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       10,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/5,     2 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/2,     4 ,     4,         20,      10,    2,      1,       100,     2,      3,       10,     0,       0,       2000,      0 ) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
input_dir="C:/Users/tcarruth/Dropbox/abft-mse/M3"
out<-M3read(input_dir)
load(paste(input_dir,"/OMI",sep=""))
load(system.file("ts2017.Rdata", package="ABTMSE"))
dat<-ts2017
render(input="C:/Users/tcarruth/Dropbox/abft-mse/R_package/ABTMSE/inst/OMreport.Rmd", output_file=paste("C:/temp/OMreport3.html",sep=""))
Base@LHw<-                 c(1/3,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     10,       100,    0,      0,        25,      0 ) # SSB index for each population
# revised 3 Base@LHw<-     c(1/3,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     10,       100,    0,      0,        50,      0 ) # SSB index for each population
# revised 2 Base@LHw<-     c(1/5,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     4,       100,    0,      0,         50,      0 ) # SSB index for each population
# Circulated: Base@LHw<-   c(1/5,     0.8 ,   0.1,       1/50,   10,    1,       0,       30,      1,      4,       100,    0,      0,         10,      0 ) # SSB index for each population
#Base@LHw<-  c(1/20,    4 ,     1,         1/20,    10,    1,      0,       10,      1,      10,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       10,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/5,     2 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/2,     4 ,     4,         20,      10,    2,      1,       100,     2,      3,       10,     0,       0,       2000,      0 ) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
input_dir="C:/Users/tcarruth/Dropbox/abft-mse/M3"
out<-M3read(input_dir)
load(paste(input_dir,"/OMI",sep=""))
load(system.file("ts2017.Rdata", package="ABTMSE"))
dat<-ts2017
render(input="C:/Users/tcarruth/Dropbox/abft-mse/R_package/ABTMSE/inst/OMreport.Rmd", output_file=paste("C:/temp/OMreport4.html",sep=""))
Base@nsel<-Base@nf
Base@seltype<-rep(3,Base@nf) # all fleets have thompson (potentially) dome-shaped selectivity except the combined other fleet
#Base@seltype[(1:length(Fleets$name))[Fleets$name%in%c("LLOTH","RRCan")]]<-2 # set longline to asymptotic
#Base@seltype[length(Base@seltype)]<-2
Base@selind<-1:Base@nf # No selectivity mirroring - selectivities correspond to fleets
Base@ratiolim<-c(0.1,0.4) # limits on the logistic slope paramter relative to position of inflection point
Base@infleclim<-c(4,15) # limits on the location of the inflection point (age)
Base@seltype
# --- (m) Movement estimation and definition ------
Base@movtype<-as.integer(1)
source("Rscripts/Data processing/Movement definitions.r") # returns movind and mov1
Base@nMP<-nrow(movind)+Base@ns*Base@np*Base@nma
Base@nmovind<-nrow(movind)
Base@movind<-movind
Base@nmov1<-nrow(mov1)
Base@mov1<-mov1
# --- Relating to likelihood functions ------
Base@CobsCV<-rep(0.025,Base@nf)        # CV on seasonal catch observations by area
#                "SPN_BB" "SPN_FR_BB" "MOR_SPN_TRAP" "MOR_POR_TRAP" "JPN_LL_Eatl_Med" "JPN_LL_NEAtl1" "JPN_LL_NEAtl2" "US_RR_66_114" "US_RR_115_144" "US_RR_177" "US_RR_145" "US_RR_195" "US_GOM_PLL1" "US_GOM_PLL2" "JPLL_GOM" "JPN_LL_West1" "JPN_LL_West2" "CAN GSL" "CAN SWNS"
Base@CPUEobsCV<-c(0.2,     0.2,        0.2,           0.2,           0.15,             0.125,          0.15,           0.2,           0.2,            0.15,       0.1,       0.15,       0.15,         0.15,         0.15,      0.1,           0.2,           0.5,      0.5) # CV on seasonal CPUE observations by area
#              "FR_AER_SUV1" "FR_AER_SUV2" "MED_LAR_SUV" "CAN_ACO_SUV" "GOM_LAR_SUV" "GBYP_AER_SUV"
Base@IobsCV<- c(0.1,          0.15,         0.1,          0.1,          0.1,          0.125)         # CV on fishery independent indices
Base@RDCV<-0.5/(Base@ny/(Base@ny/yblock))^0.5 # CV for penalty on recruitment deviations (if blocked this is Std. Err.)
Base@nSSBprior=1
Base@SSBprior = matrix(c(1,1,20000),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@SSBCV=10                       # default is a very tight prior on SSB
Base@nDepprior=1
Base@Depprior = matrix(c(1,1,0.5),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@DepCV=10                       # default is a very tight prior on SSB
Base@FCV=0.3                          # Prior precision of season-area deviations around mean F
Base@movCV=1                          # Prior precision of deviations from homogeneous movement
Base@selCV=0.8                        # Prior precision of selectivity parameters
Base@SSBincCV=0.01                    # Prior precision of SSB increase ratio
Base@nLHw<-as.integer(15)             # number of likelihood components that may be weighted
#                           (1 catch, 2 cpue, 3 FIindex, 4 Lcomp, 5 SOO, 6 PSAT, 7 PSAT2, 8 RecDev, 9 mov,  10 sel,  11 SRA, 12 SSB, 13 SSBinc, 14 Fmod, 15 BSfrac)",datfile,1,append=T)
Base@LHw<-                 c(1/3,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     10,       100,    0,      0,        25,      0 ) # SSB index for each population
# revised 3 Base@LHw<-     c(1/3,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     10,       100,    0,      0,        50,      0 ) # SSB index for each population
# revised 2 Base@LHw<-     c(1/5,     0.8 ,   0.1,       1/50,    10,    10,     0,       30,       10,     4,       100,    0,      0,         50,      0 ) # SSB index for each population
# Circulated: Base@LHw<-   c(1/5,     0.8 ,   0.1,       1/50,   10,    1,       0,       30,      1,      4,       100,    0,      0,         10,      0 ) # SSB index for each population
#Base@LHw<-  c(1/20,    4 ,     1,         1/20,    10,    1,      0,       10,      1,      10,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       10,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/10,    4 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/5,     2 ,     2,         10,      10,    1,      0,       40,      1,      3,       100,     0,       0,      10000,     0 ) # SSB index for each population
#Base@LHw<-  c(1/2,     4 ,     4,         20,      10,    2,      1,       100,     2,      3,       10,     0,       0,       2000,      0 ) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
Base@seltype
input_dir="C:/Users/tcarruth/Dropbox/abft-mse/M3"
out<-M3read(input_dir)
load(paste(input_dir,"/OMI",sep=""))
load(system.file("ts2017.Rdata", package="ABTMSE"))
dat<-ts2017
render(input="C:/Users/tcarruth/Dropbox/abft-mse/R_package/ABTMSE/inst/OMreport.Rmd", output_file=paste("C:/temp/OMreport4.html",sep=""))
pin_from_par("C:/Users/tcarruth/Dropbox/abft-mse/M3")
shiny::runApp('~/GitHub/FRAME/inst/shiny_apps/FRAME')
shiny::runApp()
runApp()
Just
temp<-readRDS("OM_autosave.rda")
class(temp)
temp<-readRDS("Data_autosave.rda")
class(temp)
load("tcarruth_autosave.frame")
readRDS("tcarruth_autosave.frame")
temp<-readRDS("tcarruth_autosave.frame")
Just<-temp[[2]]
isjust<-function(x)sum(x=="No justification was provided")
lapply(Just,isjust)
sum(lapply(Just,isjust))
sum(unlist(lapply(Just,isjust)))
runApp()
sum(unlist(lapply(Just,isjust)))==0
isjust<-function(x)sum(x=="No justification was provided")
sum(unlist(lapply(Just,isjust))
)
sum(unlist(lapply(Just,isjust)))==0
runApp()
int(sum(unlist(lapply(Just,isjust)))==0)
as.integer(sum(unlist(lapply(Just,isjust)))==0)
runApp()
burnin=10
readRDS("MSEobj")
readRDS("MSEobj_reb")
load("MSEobj")
load("MSEobj_reb")
load("MSEobj")
load("MSEobj_reb")
burnin<-10
rnd=0
source('~/GitHub/FRAME/inst/shiny_apps/FRAME/Performance_table.R')
Ptab1<<-Ptab(MSEobj,MSEobj_reb,burnin=burnin,rnd=0)
Ptab1
thresh=c(70, 50, 70, 80, 50)
fease=T
Ptab1<<-Ptab(MSEobj,MSEobj_reb,burnin=burnin,rnd=0)
load("MSEobj")
load("MSEobj_reb")
burnin<-10
rnd=0
thresh=c(70, 50, 70, 80, 50)
fease=T
Ptab1<<-Ptab(MSEobj,MSEobj_reb,burnin=burnin,rnd=0)
Ptab2<<-Ptab_ord(Ptab1,burnin=burnin,ntop=10, Eval=T,fease=fease,thresh=thresh) # This is where MPcols_app is defined (Eval=F)
load("PanelState")
Ptab2<<-Ptab_ord(Ptab1,burnin=burnin,ntop=10, Eval=T,fease=fease,thresh=thresh) # This is where MPcols_app is defined (Eval=F)
Ptab2
MPs<-as.character(Ptab1$MP)
#MPs<-avail('MP')
if(is.na(ntop))ntop<-nrow(Ptab1)
if(ntop>nrow(Ptab1))ntop<-nrow(Ptab1)
if(ntop<1)ntop<-1
# Proper Data Feasibility based on complex fease analysis by MP
tempdat<-tempdat0<-DLMtool::SimulatedData
tempdat@Cat<-array(NA,dim(tempdat0@Cat))
tempdat@Ind<-array(NA,dim(tempdat0@Ind))
tempdat@CAL<-array(NA,dim(tempdat0@CAL))
tempdat@CAA<-array(NA,dim(tempdat0@CAA))
tempdat@vbK<-rep(NA,length(tempdat0@vbK))
tempdat@Abun<-rep(NA,length(tempdat0@Abun))
ndaty<-dim(tempdat@Cat)[2]
cond<-unlist(PanelState[[3]][1]) # cond=rep(T,9) cond=c(T,T,F,T,T,T,T,T,T)
FeasePos<-c("Catch","Catch","Index","Index","Index","Catch_at_length","Catch_at_age","Growth","Abundance")
Datslot<-c("Cat","Cat","Ind",  "Ind","Ind","CAL","CAA","vbK","Abun")
yrrange<-c(ndaty, 5,    ndaty,  5,    ndaty,        2,                2, NA, NA)
fease
for(i in 1:length(Datslot)){
if(cond[i]){ # if user has specified that data are available
if(!is.na(yrrange[i])){ # it not a vector of values
ndim<-length(dim(slot(tempdat0,Datslot[i])))
if(ndim==2){ # is a matrix
slot(tempdat,Datslot[i])[,ndaty-(yrrange[i]:1)+1]<-slot(tempdat0,Datslot[i])[,ndaty-(yrrange[i]:1)+1]
}else{ # is a 3D array
slot(tempdat,Datslot[i])[,ndaty-(yrrange[i]:1)+1,]<-slot(tempdat0,Datslot[i])[,ndaty-(yrrange[i]:1)+1,]
}
}else{
slot(tempdat,Datslot[i])<-slot(tempdat0,Datslot[i])
}
}
}
if(!cond[3])tempdat@Dep<-rep(NA,2)
DFeasible<<-Fease(tempdat)
PanelState[[3]][1]
PanelState[[2]][1]
PanelState[[2]][1]<-c(TRUE,FALSE,TRUE,TRUE)
Ptab2<<-Ptab_ord(Ptab1,burnin=burnin,ntop=10, Eval=T,fease=fease,thresh=thresh) # This is where MPcols_app is defined (Eval=F)
Ptab2
PanelState[[2]][1]
PanelState[[2]][1]<-c(TRUE,FALSE,TRUE,TRUE)
PanelState[[2]][1]
load("PanelState")
PanelState[[2]][1]
PanelState[[2]][1][[1]]<-c(TRUE,FALSE,TRUE,TRUE)
Ptab2<<-Ptab_ord(Ptab1,burnin=burnin,ntop=10, Eval=T,fease=fease,thresh=thresh) # This is where MPcols_app is defined (Eval=F)
Ptab2
runApp()
MP_Type
MPs<-as.character(Ptab1$MP)
#MPs<-avail('MP')
if(is.na(ntop))ntop<-nrow(Ptab1)
if(ntop>nrow(Ptab1))ntop<-nrow(Ptab1)
if(ntop<1)ntop<-1
# Proper Data Feasibility based on complex fease analysis by MP
tempdat<-tempdat0<-DLMtool::SimulatedData
tempdat@Cat<-array(NA,dim(tempdat0@Cat))
tempdat@Ind<-array(NA,dim(tempdat0@Ind))
tempdat@CAL<-array(NA,dim(tempdat0@CAL))
tempdat@CAA<-array(NA,dim(tempdat0@CAA))
tempdat@vbK<-rep(NA,length(tempdat0@vbK))
tempdat@Abun<-rep(NA,length(tempdat0@Abun))
ndaty<-dim(tempdat@Cat)[2]
cond<-unlist(PanelState[[3]][1]) # cond=rep(T,9) cond=c(T,T,F,T,T,T,T,T,T)
FeasePos<-c("Catch","Catch","Index","Index","Index","Catch_at_length","Catch_at_age","Growth","Abundance")
Datslot<-c("Cat","Cat","Ind",  "Ind","Ind","CAL","CAA","vbK","Abun")
yrrange<-c(ndaty, 5,    ndaty,  5,    ndaty,        2,                2, NA, NA)
ntop=10
MPs<-as.character(Ptab1$MP)
#MPs<-avail('MP')
if(is.na(ntop))ntop<-nrow(Ptab1)
if(ntop>nrow(Ptab1))ntop<-nrow(Ptab1)
if(ntop<1)ntop<-1
# Proper Data Feasibility based on complex fease analysis by MP
tempdat<-tempdat0<-DLMtool::SimulatedData
tempdat@Cat<-array(NA,dim(tempdat0@Cat))
tempdat@Ind<-array(NA,dim(tempdat0@Ind))
tempdat@CAL<-array(NA,dim(tempdat0@CAL))
tempdat@CAA<-array(NA,dim(tempdat0@CAA))
tempdat@vbK<-rep(NA,length(tempdat0@vbK))
tempdat@Abun<-rep(NA,length(tempdat0@Abun))
ndaty<-dim(tempdat@Cat)[2]
cond<-unlist(PanelState[[3]][1]) # cond=rep(T,9) cond=c(T,T,F,T,T,T,T,T,T)
FeasePos<-c("Catch","Catch","Index","Index","Index","Catch_at_length","Catch_at_age","Growth","Abundance")
Datslot<-c("Cat","Cat","Ind",  "Ind","Ind","CAL","CAA","vbK","Abun")
yrrange<-c(ndaty, 5,    ndaty,  5,    ndaty,        2,                2, NA, NA)
for(i in 1:length(Datslot)){
if(cond[i]){ # if user has specified that data are available
if(!is.na(yrrange[i])){ # it not a vector of values
ndim<-length(dim(slot(tempdat0,Datslot[i])))
if(ndim==2){ # is a matrix
slot(tempdat,Datslot[i])[,ndaty-(yrrange[i]:1)+1]<-slot(tempdat0,Datslot[i])[,ndaty-(yrrange[i]:1)+1]
}else{ # is a 3D array
slot(tempdat,Datslot[i])[,ndaty-(yrrange[i]:1)+1,]<-slot(tempdat0,Datslot[i])[,ndaty-(yrrange[i]:1)+1,]
}
}else{
slot(tempdat,Datslot[i])<-slot(tempdat0,Datslot[i])
}
}
}
if(!cond[3])tempdat@Dep<-rep(NA,2)
DFeasible<-Fease(tempdat)
DFeasible
cond<-unlist(PanelState[[2]][1]) # cond=rep(T,4)
runMPs <- applyMP(tempdat0, MPs, reps = 2, nsims=1, silent=TRUE)
recs <- runMPs[[1]]
type <- matrix(0, nrow=length(MPs),ncol=4) # TAC TAE SL MPA
for (mm in seq_along(recs)) {
type[mm,1] <- as.integer(length(recs[[mm]]$TAC) > 0)
type[mm,2] <- as.integer(length(recs[[mm]]$Effort)>0)
type[mm,3] <- as.integer(length(recs[[mm]]$LR5)>0)
type[mm,4] <- as.integer(!is.na(recs[[mm]]$Spatial[1,1]))
}
DFeasible<-unique(c(DFeasible,MPs[(type[,4]==1|type[,3]==1) & apply(type,1,sum)==1])) # Size limits and area closures might not need data
DFeasible
totneeded<-apply(type,1,sum)
speced<-matrix(rep(as.integer(cond),each=length(MPs)),nrow=length(MPs))
MFeasible<-MPs[apply(speced*type,1,sum)==totneeded]
MFeasible
speced
runApp()
shiny::runApp()
Ptab2
runApp()
